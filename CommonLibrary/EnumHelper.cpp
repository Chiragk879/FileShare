#include "stdafx.h"

using namespace IMFS;

string 
EnumHelper ::  NtStatusToString(NtStatus type)
{
	switch(type)
	{
		case STATUS_OK:										return L"Success";
		case STATUS_NO_MORE_FILES:							return L"No more files";
		case STATUS_EA_LIST_INCONSISTENT:					return L"EA list inconsistent";
		case STATUS_PENDING:								return L"Pending";
		case STATUS_UNSUCCESSFUL:							return L"Unsuccessful";
		case STATUS_NOT_IMPLEMENTED:						return L"Not implemented";
		case STATUS_INVALID_INFO_CLASS:						return L"Invalid info class";
		case STATUS_INFO_LENGTH_MISMATCH:					return L"Info length mismatch";
		case STATUS_ACCESS_VIOLATION:						return L"Access violation";
		case STATUS_IN_PAGE_ERROR:							return L"In page error";
		case STATUS_PAGEFILE_QUOTA:							return L"Pagefile quota";
		case STATUS_INVALID_HANDLE:							return L"Invalid handle";
		case STATUS_BAD_INITIAL_STACK:						return L"Bad initial stack";
		case STATUS_BAD_INITIAL_PC:							return L"Bad initial pc";
		case STATUS_INVALID_CID:							return L"Invalid cid";
		case STATUS_TIMER_NOT_CANCELED:						return L"Timer not canceled";
		case STATUS_INVALID_PARAMETER:						return L"Invalid parameter";
		case STATUS_NO_SUCH_DEVICE:							return L"No such device";
		case STATUS_NO_SUCH_FILE:							return L"No such file";
		case STATUS_INVALID_DEVICE_REQUEST:					return L"Invalid device request";
		case STATUS_END_OF_FILE:							return L"End of file";
		case STATUS_WRONG_VOLUME:							return L"Wrong volume";
		case STATUS_NO_MEDIA_IN_DEVICE:						return L"No media in device";
		case STATUS_UNRECOGNIZED_MEDIA:						return L"Unrecognized media";
		case STATUS_NONEXISTENT_SECTOR:						return L"Nonexistent sector";
		case STATUS_MORE_PROCESSING_REQUIRED:				return L"More processing required";
		case STATUS_NO_MEMORY:								return L"No memory";
		case STATUS_CONFLICTING_ADDRESSES:					return L"Conflicting addresses";
		case STATUS_NOT_MAPPED_VIEW:						return L"Not mapped view";
		case STATUS_UNABLE_TO_FREE_VM:						return L"Unable to free vm";
		case STATUS_UNABLE_TO_DELETE_SECTION:				return L"Unable to delete section";
		case STATUS_INVALID_SYSTEM_SERVICE:					return L"Invalid system service";
		case STATUS_ILLEGAL_INSTRUCTION:					return L"Illegal instruction";
		case STATUS_INVALID_LOCK_SEQUENCE:					return L"Invalid lock sequence";
		case STATUS_INVALID_VIEW_SIZE:						return L"Invalid view size";
		case STATUS_INVALID_FILE_FOR_SECTION:				return L"Invalid file for section";
		case STATUS_ALREADY_COMMITTED:						return L"Already committed";
		case STATUS_ACCESS_DENIED:							return L"Access denied";
		case STATUS_BUFFER_TOO_SMALL:						return L"Buffer too small";
		case STATUS_OBJECT_TYPE_MISMATCH:					return L"Object type mismatch";
		case STATUS_NONCONTINUABLE_EXCEPTION:				return L"Noncontinuable exception";
		case STATUS_INVALID_DISPOSITION:					return L"Invalid disposition";
		case STATUS_UNWIND:									return L"Unwind";
		case STATUS_BAD_STACK:								return L"Bad stack";
		case STATUS_INVALID_UNWIND_TARGET:					return L"Invalid unwind target";
		case STATUS_NOT_LOCKED:								return L"Not locked";
		case STATUS_PARITY_ERROR:							return L"Parity error";
		case STATUS_UNABLE_TO_DECOMMIT_VM:					return L"Unable to decommit vm";
		case STATUS_NOT_COMMITTED:							return L"Not committed";
		case STATUS_INVALID_PORT_ATTRIBUTES:				return L"Invalid port attributes";
		case STATUS_PORT_MESSAGE_TOO_LONG:					return L"Port message too long";
		case STATUS_INVALID_PARAMETER_MIX:					return L"Invalid parameter mix";
		case STATUS_INVALID_QUOTA_LOWER:					return L"Invalid quota lower";
		case STATUS_DISK_CORRUPT_ERROR:						return L"Disk corrupt error";
		case STATUS_OBJECT_NAME_INVALID:					return L"Object name invalid";
		case STATUS_OBJECT_NAME_NOT_FOUND:					return L"Object name not found";
		case STATUS_OBJECT_NAME_COLLISION:					return L"Object name collision";
		case STATUS_PORT_DISCONNECTED:						return L"Port disconnected";
		case STATUS_DEVICE_ALREADY_ATTACHED:				return L"Device already attached";
		case STATUS_OBJECT_PATH_INVALID:					return L"Object path invalid";
		case STATUS_OBJECT_PATH_NOT_FOUND:					return L"Object path not found";
		case STATUS_OBJECT_PATH_SYNTAX_BAD:					return L"Object path syntax bad";
		case STATUS_DATA_OVERRUN:							return L"Data overrun";
		case STATUS_DATA_LATE_ERROR:						return L"Data late error";
		case STATUS_DATA_ERROR:								return L"Data error";
		case STATUS_CRC_ERROR:								return L"CRC error";
		case STATUS_SECTION_TOO_BIG:						return L"Section too big";
		case STATUS_PORT_CONNECTION_REFUSED:				return L"Port connection refused";
		case STATUS_INVALID_PORT_HANDLE:					return L"Invalid port handle";
		case STATUS_SHARING_VIOLATION:						return L"Sharing violation";
		case STATUS_QUOTA_EXCEEDED:							return L"Quota exceeded";
		case STATUS_INVALID_PAGE_PROTECTION:				return L"Invalid page protection";
		case STATUS_MUTANT_NOT_OWNED:						return L"Mutant not owned";
		case STATUS_SEMAPHORE_LIMIT_EXCEEDED:				return L"Semaphore limit exceeded";
		case STATUS_PORT_ALREADY_SET:						return L"Port already set";
		case STATUS_SECTION_NOT_IMAGE:						return L"Section not image";
		case STATUS_SUSPEND_COUNT_EXCEEDED:					return L"Suspend count exceeded";
		case STATUS_THREAD_IS_TERMINATING:					return L"Thread is terminating";
		case STATUS_BAD_WORKING_SET_LIMIT:					return L"Bad working set limit";
		case STATUS_INCOMPATIBLE_FILE_MAP:					return L"Incompatible file map";
		case STATUS_SECTION_PROTECTION:						return L"Section protection";
		case STATUS_EAS_NOT_SUPPORTED:						return L"EAS not supported";
		case STATUS_EA_TOO_LARGE:							return L"EA too large";
		case STATUS_NONEXISTENT_EA_ENTRY:					return L"Nonexistent ea entry";
		case STATUS_NO_EAS_ON_FILE:							return L"No eas on file";
		case STATUS_EA_CORRUPT_ERROR:						return L"EA corrupt error";
		case STATUS_FILE_LOCK_CONFLICT:						return L"File lock conflict";
		case STATUS_LOCK_NOT_GRANTED:						return L"Lock not granted";
		case STATUS_DELETE_PENDING:							return L"Delete pending";
		case STATUS_CTL_FILE_NOT_SUPPORTED:					return L"Ctl file not supported";
		case STATUS_UNKNOWN_REVISION:						return L"Unknown revision";
		case STATUS_REVISION_MISMATCH:						return L"Revision mismatch";
		case STATUS_INVALID_OWNER:							return L"Invalid owner";
		case STATUS_INVALID_PRIMARY_GROUP:					return L"Invalid primary group";
		case STATUS_NO_IMPERSONATION_TOKEN:					return L"No impersonation token";
		case STATUS_CANT_DISABLE_MANDATORY:					return L"Cant disable mandatory";
		case STATUS_NO_LOGON_SERVERS:						return L"No logon servers";
		case STATUS_NO_SUCH_LOGON_SESSION:					return L"No such logon session";
		case STATUS_NO_SUCH_PRIVILEGE:						return L"No such privilege";
		case STATUS_PRIVILEGE_NOT_HELD:						return L"Privilege not held";
		case STATUS_INVALID_ACCOUNT_NAME:					return L"Invalid account name";
		case STATUS_USER_EXISTS:							return L"User exists";
		case STATUS_NO_SUCH_USER:							return L"No such user";
		case STATUS_GROUP_EXISTS:							return L"Group exists";
		case STATUS_NO_SUCH_GROUP:							return L"No such group";
		case STATUS_MEMBER_IN_GROUP:						return L"Member in group";
		case STATUS_MEMBER_NOT_IN_GROUP:					return L"Member not in group";
		case STATUS_LAST_ADMIN:								return L"Last admin";
		case STATUS_WRONG_PASSWORD:							return L"Wrong password";
		case STATUS_ILL_FORMED_PASSWORD:					return L"Ill formed password";
		case STATUS_PASSWORD_RESTRICTION:					return L"Password restriction";
		case STATUS_LOGON_FAILURE:							return L"Logon failure";
		case STATUS_ACCOUNT_RESTRICTION:					return L"Account restriction";
		case STATUS_INVALID_LOGON_HOURS:					return L"Invalid logon hours";
		case STATUS_INVALID_WORKSTATION:					return L"Invalid workstation";
		case STATUS_PASSWORD_EXPIRED:						return L"Password expired";
		case STATUS_ACCOUNT_DISABLED:						return L"Account disabled";
		case STATUS_NONE_MAPPED:							return L"None mapped";
		case STATUS_TOO_MANY_LUIDS_REQUESTED:				return L"Too many luids requested";
		case STATUS_LUIDS_EXHAUSTED:						return L"Luids exhausted";
		case STATUS_INVALID_SUB_AUTHORITY:					return L"Invalid sub authority";
		case STATUS_INVALID_ACL:							return L"Invalid acl";
		case STATUS_INVALID_SID:							return L"Invalid sid";
		case STATUS_INVALID_SECURITY_DESCR:					return L"Invalid security descr";
		case STATUS_PROCEDURE_NOT_FOUND:					return L"Procedure not found";
		case STATUS_INVALID_IMAGE_FORMAT:					return L"Invalid image format";
		case STATUS_NO_TOKEN:								return L"No token";
		case STATUS_BAD_INHERITANCE_ACL:					return L"Bad inheritance acl";
		case STATUS_RANGE_NOT_LOCKED:						return L"Range not locked";
		case STATUS_DISK_FULL:								return L"Disk full";
		case STATUS_SERVER_DISABLED:						return L"Server disabled";
		case STATUS_SERVER_NOT_DISABLED:					return L"Server not disabled";
		case STATUS_TOO_MANY_GUIDS_REQUESTED:				return L"Too many guids requested";
		case STATUS_GUIDS_EXHAUSTED:						return L"Guids exhausted";
		case STATUS_INVALID_ID_AUTHORITY:					return L"Invalid id authority";
		case STATUS_AGENTS_EXHAUSTED:						return L"Agents exhausted";
		case STATUS_INVALID_VOLUME_LABEL:					return L"Invalid volume label";
		case STATUS_SECTION_NOT_EXTENDED:					return L"Section not extended";
		case STATUS_NOT_MAPPED_DATA:						return L"Not mapped data";
		case STATUS_RESOURCE_DATA_NOT_FOUND:				return L"Resource data not found";
		case STATUS_RESOURCE_TYPE_NOT_FOUND:				return L"Resource type not found";
		case STATUS_RESOURCE_NAME_NOT_FOUND:				return L"Resource name not found";
		case STATUS_ARRAY_BOUNDS_EXCEEDED:					return L"Array bounds exceeded";
		case STATUS_FLOAT_DENORMAL_OPERAND:					return L"Float denormal operand";
		case STATUS_FLOAT_DIVIDE_BY_ZERO:					return L"Float divide by zero";
		case STATUS_FLOAT_INEXACT_RESULT:					return L"Float inexact result";
		case STATUS_FLOAT_INVALID_OPERATION:				return L"Float invalid operation";
		case STATUS_FLOAT_OVERFLOW:							return L"Float overflow";
		case STATUS_FLOAT_STACK_CHECK:						return L"Float stack check";
		case STATUS_FLOAT_UNDERFLOW:						return L"Float underflow";
		case STATUS_INTEGER_DIVIDE_BY_ZERO:					return L"Integer divide by zero";
		case STATUS_INTEGER_OVERFLOW:						return L"Integer overflow";
		case STATUS_PRIVILEGED_INSTRUCTION:					return L"Privileged instruction";
		case STATUS_TOO_MANY_PAGING_FILES:					return L"Too many paging files";
		case STATUS_FILE_INVALID:							return L"File invalid";
		case STATUS_ALLOTTED_SPACE_EXCEEDED:				return L"Allotted space exceeded";
		case STATUS_INSUFFICIENT_RESOURCES:					return L"Insufficient resources";
		case STATUS_DFS_EXIT_PATH_FOUND:					return L"Dfs exit path found";
		case STATUS_DEVICE_DATA_ERROR:						return L"Device data error";
		case STATUS_DEVICE_NOT_CONNECTED:					return L"Device not connected";
		case STATUS_DEVICE_POWER_FAILURE:					return L"Device power failure";
		case STATUS_FREE_VM_NOT_AT_BASE:					return L"Free vm not at base";
		case STATUS_MEMORY_NOT_ALLOCATED:					return L"Memory not allocated";
		case STATUS_WORKING_SET_QUOTA:						return L"Working set quota";
		case STATUS_MEDIA_WRITE_PROTECTED:					return L"Media write protected";
		case STATUS_DEVICE_NOT_READY:						return L"Device not ready";
		case STATUS_INVALID_GROUP_ATTRIBUTES:				return L"Invalid group attributes";
		case STATUS_BAD_IMPERSONATION_LEVEL:				return L"Bad impersonation level";
		case STATUS_CANT_OPEN_ANONYMOUS:					return L"Can't open anonymous";
		case STATUS_BAD_VALIDATION_CLASS:					return L"Bad validation class";
		case STATUS_BAD_TOKEN_TYPE:							return L"Bad token type";
		case STATUS_BAD_MASTER_BOOT_RECORD:					return L"Bad master boot record";
		case STATUS_INSTRUCTION_MISALIGNMENT:				return L"Instruction misalignment";
		case STATUS_INSTANCE_NOT_AVAILABLE:					return L"Instance not available";
		case STATUS_PIPE_NOT_AVAILABLE:						return L"Pipe not available";
		case STATUS_INVALID_PIPE_STATE:						return L"Invalid pipe state";
		case STATUS_PIPE_BUSY:								return L"Pipe busy";
		case STATUS_ILLEGAL_FUNCTION:						return L"Illegal function";
		case STATUS_PIPE_DISCONNECTED:						return L"Pipe disconnected";
		case STATUS_PIPE_CLOSING:							return L"Pipe closing";
		case STATUS_PIPE_CONNECTED:							return L"Pipe connected";
		case STATUS_PIPE_LISTENING:							return L"Pipe listening";
		case STATUS_INVALID_READ_MODE:						return L"Invalid read mode";
		case STATUS_IO_TIMEOUT:								return L"IO timeout";
		case STATUS_FILE_FORCED_CLOSED:						return L"File forced closed";
		case STATUS_PROFILING_NOT_STARTED:					return L"Profiling not started";
		case STATUS_PROFILING_NOT_STOPPED:					return L"Profiling not stopped";
		case STATUS_COULD_NOT_INTERPRET:					return L"Could not interpret";
		case STATUS_FILE_IS_A_DIRECTORY:					return L"File is a directory";
		case STATUS_NOT_SUPPORTED:							return L"Not supported";
		case STATUS_REMOTE_NOT_LISTENING:					return L"Remote not listening";
		case STATUS_DUPLICATE_NAME:							return L"Duplicate name";
		case STATUS_BAD_NETWORK_PATH:						return L"Bad network path";
		case STATUS_NETWORK_BUSY:							return L"Network busy";
		case STATUS_DEVICE_DOES_NOT_EXIST:					return L"Device does not exist";
		case STATUS_TOO_MANY_COMMANDS:						return L"Too many commands";
		case STATUS_ADAPTER_HARDWARE_ERROR:					return L"Adapter hardware error";
		case STATUS_INVALID_NETWORK_RESPONSE:				return L"Invalid network response";
		case STATUS_UNEXPECTED_NETWORK_ERROR:				return L"Unexpected network error";
		case STATUS_BAD_REMOTE_ADAPTER:						return L"Bad remote adapter";
		case STATUS_PRINT_QUEUE_FULL:						return L"Print queue full";
		case STATUS_NO_SPOOL_SPACE:							return L"No spool space";
		case STATUS_PRINT_CANCELLED:						return L"Print cancelled";
		case STATUS_NETWORK_NAME_DELETED:					return L"Network name deleted";
		case STATUS_NETWORK_ACCESS_DENIED:					return L"Network access denied";
		case STATUS_BAD_DEVICE_TYPE:						return L"Bad device type";
		case STATUS_BAD_NETWORK_NAME:						return L"Bad network name";
		case STATUS_TOO_MANY_NAMES:							return L"Too many names";
		case STATUS_TOO_MANY_SESSIONS:						return L"Too many sessions";
		case STATUS_SHARING_PAUSED:							return L"Sharing paused";
		case STATUS_REQUEST_NOT_ACCEPTED:					return L"Request not accepted";
		case STATUS_REDIRECTOR_PAUSED:						return L"Redirector paused";
		case STATUS_NET_WRITE_FAULT:						return L"Net write fault";
		case STATUS_PROFILING_AT_LIMIT:						return L"Profiling at limit";
		case STATUS_NOT_SAME_DEVICE:						return L"Not same device";
		case STATUS_FILE_RENAMED:							return L"File renamed";
		case STATUS_VIRTUAL_CIRCUIT_CLOSED:					return L"Virtual circuit closed";
		case STATUS_NO_SECURITY_ON_OBJECT:					return L"No security on object";
		case STATUS_CANT_WAIT:								return L"Cant wait";
		case STATUS_PIPE_EMPTY:								return L"Pipe empty";
		case STATUS_CANT_ACCESS_DOMAIN_INFO:				return L"Cant access domain info";
		case STATUS_CANT_TERMINATE_SELF:					return L"Cant terminate self";
		case STATUS_INVALID_SERVER_STATE:					return L"Invalid server state";
		case STATUS_INVALID_DOMAIN_STATE:					return L"Invalid domain state";
		case STATUS_INVALID_DOMAIN_ROLE:					return L"Invalid domain role";
		case STATUS_NO_SUCH_DOMAIN:							return L"No such domain";
		case STATUS_DOMAIN_EXISTS:							return L"Domain exists";
		case STATUS_DOMAIN_LIMIT_EXCEEDED:					return L"Domain limit exceeded";
		case STATUS_OPLOCK_NOT_GRANTED:						return L"OPlock not granted";
		case STATUS_INVALID_OPLOCK_PROTOCOL:				return L"Invalid oplock protocol";
		case STATUS_INTERNAL_DB_CORRUPTION:					return L"Internal db corruption";
		case STATUS_INTERNAL_ERROR:							return L"Internal error";
		case STATUS_GENERIC_NOT_MAPPED:						return L"Generic not mapped";
		case STATUS_BAD_DESCRIPTOR_FORMAT:					return L"Bad descriptor format";
		case STATUS_INVALID_USER_BUFFER:					return L"Invalid user buffer";
		case STATUS_UNEXPECTED_IO_ERROR:					return L"Unexpected io error";
		case STATUS_UNEXPECTED_MM_CREATE_ERR:				return L"Unexpected mm create err";
		case STATUS_UNEXPECTED_MM_MAP_ERROR:				return L"Unexpected mm map error";
		case STATUS_UNEXPECTED_MM_EXTEND_ERR:				return L"Unexpected mm extend err";
		case STATUS_NOT_LOGON_PROCESS:						return L"Not logon process";
		case STATUS_LOGON_SESSION_EXISTS:					return L"Logon session exists";
		case STATUS_INVALID_PARAMETER_1:					return L"Invalid parameter 1";
		case STATUS_INVALID_PARAMETER_2:					return L"Invalid parameter 2";
		case STATUS_INVALID_PARAMETER_3:					return L"Invalid parameter 3";
		case STATUS_INVALID_PARAMETER_4:					return L"Invalid parameter 4";
		case STATUS_INVALID_PARAMETER_5:					return L"Invalid parameter 5";
		case STATUS_INVALID_PARAMETER_6:					return L"Invalid parameter 6";
		case STATUS_INVALID_PARAMETER_7:					return L"Invalid parameter 7";
		case STATUS_INVALID_PARAMETER_8:					return L"Invalid parameter 8";
		case STATUS_INVALID_PARAMETER_9:					return L"Invalid parameter 9";
		case STATUS_INVALID_PARAMETER_10:					return L"Invalid parameter 10";
		case STATUS_INVALID_PARAMETER_11:					return L"Invalid parameter 11";
		case STATUS_INVALID_PARAMETER_12:					return L"Invalid parameter 12";
		case STATUS_REDIRECTOR_NOT_STARTED:					return L"Redirector not started";
		case STATUS_REDIRECTOR_STARTED:						return L"Redirector started";
		case STATUS_STACK_OVERFLOW:							return L"Stack overflow";
		case STATUS_NO_SUCH_PACKAGE:						return L"No such package";
		case STATUS_BAD_FUNCTION_TABLE:						return L"Bad function table";
		case STATUS_DIRECTORY_NOT_EMPTY:					return L"Directory not empty";
		case STATUS_FILE_CORRUPT_ERROR:						return L"File corrupt error";
		case STATUS_NOT_A_DIRECTORY:						return L"Not a directory";
		case STATUS_BAD_LOGON_SESSION_STATE:				return L"Bad logon session state";
		case STATUS_LOGON_SESSION_COLLISION:				return L"Logon session collision";
		case STATUS_NAME_TOO_LONG:							return L"Name too long";
		case STATUS_FILES_OPEN:								return L"Files open";
		case STATUS_CONNECTION_IN_USE:						return L"Connection in use";
		case STATUS_MESSAGE_NOT_FOUND:						return L"Message not found";
		case STATUS_PROCESS_IS_TERMINATING:					return L"Process is terminating";
		case STATUS_INVALID_LOGON_TYPE:						return L"Invalid logon type";
		case STATUS_NO_GUID_TRANSLATION:					return L"No guid translation";
		case STATUS_CANNOT_IMPERSONATE:						return L"Cannot impersonate";
		case STATUS_IMAGE_ALREADY_LOADED:					return L"Image already loaded";
		case STATUS_ABIOS_NOT_PRESENT:						return L"Abios not present";
		case STATUS_ABIOS_LID_NOT_EXIST:					return L"Abios lid not exist";
		case STATUS_ABIOS_LID_ALREADY_OWNED:				return L"Abios lid already owned";
		case STATUS_ABIOS_NOT_LID_OWNER:					return L"Abios not lid owner";
		case STATUS_ABIOS_INVALID_COMMAND:					return L"Abios invalid command";
		case STATUS_ABIOS_INVALID_LID:						return L"Abios invalid lid";
		case STATUS_ABIOS_SELECTOR_NOT_AVAILABLE:			return L"Abios selector not available";
		case STATUS_ABIOS_INVALID_SELECTOR:					return L"Abios invalid selector";
		case STATUS_NO_LDT:									return L"No ldt";
		case STATUS_INVALID_LDT_SIZE:						return L"Invalid ldt size";
		case STATUS_INVALID_LDT_OFFSET:						return L"Invalid ldt offset";
		case STATUS_INVALID_LDT_DESCRIPTOR:					return L"Invalid ldt descriptor";
		case STATUS_INVALID_IMAGE_NE_FORMAT:				return L"Invalid image ne format";
		case STATUS_RXACT_INVALID_STATE:					return L"Rxact invalid state";
		case STATUS_RXACT_COMMIT_FAILURE:					return L"Rxact commit failure";
		case STATUS_MAPPED_FILE_SIZE_ZERO:					return L"Mapped file size zero";
		case STATUS_TOO_MANY_OPENED_FILES:					return L"Too many opened files";
		case STATUS_CANCELLED:								return L"Cancelled";
		case STATUS_CANNOT_DELETE:							return L"Cannot delete";
		case STATUS_INVALID_COMPUTER_NAME:					return L"Invalid computer name";
		case STATUS_FILE_DELETED:							return L"File deleted";
		case STATUS_SPECIAL_ACCOUNT:						return L"Special account";
		case STATUS_SPECIAL_GROUP:							return L"Special group";
		case STATUS_SPECIAL_USER:							return L"Special user";
		case STATUS_MEMBERS_PRIMARY_GROUP:					return L"Members primary group";
		case STATUS_FILE_CLOSED:							return L"File closed";
		case STATUS_TOO_MANY_THREADS:						return L"Too many threads";
		case STATUS_THREAD_NOT_IN_PROCESS:					return L"Thread not in process";
		case STATUS_TOKEN_ALREADY_IN_USE:					return L"Token already in use";
		case STATUS_PAGEFILE_QUOTA_EXCEEDED:				return L"Pagefile quota exceeded";
		case STATUS_COMMITMENT_LIMIT:						return L"Commitment limit";
		case STATUS_INVALID_IMAGE_LE_FORMAT:				return L"Invalid image le format";
		case STATUS_INVALID_IMAGE_NOT_MZ:					return L"Invalid image not mz";
		case STATUS_INVALID_IMAGE_PROTECT:					return L"Invalid image protect";
		case STATUS_INVALID_IMAGE_WIN_16:					return L"Invalid image win 16";
		case STATUS_LOGON_SERVER_CONFLICT:					return L"Logon server conflict";
		case STATUS_TIME_DIFFERENCE_AT_DC:					return L"Time difference at dc";
		case STATUS_SYNCHRONIZATION_REQUIRED:				return L"Synchronization required";
		case STATUS_DLL_NOT_FOUND:							return L"DLL not found";
		case STATUS_OPEN_FAILED:							return L"Open failed";
		case STATUS_IO_PRIVILEGE_FAILED:					return L"IO privilege failed";
		case STATUS_ORDINAL_NOT_FOUND:						return L"Ordinal not found";
		case STATUS_ENTRYPOINT_NOT_FOUND:					return L"Entrypoint not found";
		case STATUS_CONTROL_C_EXIT:							return L"Control c exit";
		case STATUS_LOCAL_DISCONNECT:						return L"Local disconnect";
		case STATUS_REMOTE_DISCONNECT:						return L"Remote disconnect";
		case STATUS_REMOTE_RESOURCES:						return L"Remote resources";
		case STATUS_LINK_FAILED:							return L"Link failed";
		case STATUS_LINK_TIMEOUT:							return L"Link timeout";
		case STATUS_INVALID_CONNECTION:						return L"Invalid connection";
		case STATUS_INVALID_ADDRESS:						return L"Invalid address";
		case STATUS_DLL_INIT_FAILED:						return L"DLL init failed";
		case STATUS_MISSING_SYSTEMFILE:						return L"Missing systemfile";
		case STATUS_UNHANDLED_EXCEPTION:					return L"Unhandled exception";
		case STATUS_APP_INIT_FAILURE:						return L"App init failure";
		case STATUS_PAGEFILE_CREATE_FAILED:					return L"Pagefile create failed";
		case STATUS_NO_PAGEFILE:							return L"No pagefile";
		case STATUS_INVALID_LEVEL:							return L"Invalid level";
		case STATUS_WRONG_PASSWORD_CORE:					return L"Wrong password core";
		case STATUS_ILLEGAL_FLOAT_CONTEXT:					return L"Illegal float context";
		case STATUS_PIPE_BROKEN:							return L"Pipe broken";
		case STATUS_REGISTRY_CORRUPT:						return L"Registry corrupt";
		case STATUS_REGISTRY_IO_FAILED:						return L"Registry io failed";
		case STATUS_NO_EVENT_PAIR:							return L"No event pair";
		case STATUS_UNRECOGNIZED_VOLUME:					return L"Unrecognized volume";
		case STATUS_SERIAL_NO_DEVICE_INITED:				return L"Serial no device inited";
		case STATUS_NO_SUCH_ALIAS:							return L"No such alias";
		case STATUS_MEMBER_NOT_IN_ALIAS:					return L"Member not in alias";
		case STATUS_MEMBER_IN_ALIAS:						return L"Member in alias";
		case STATUS_ALIAS_EXISTS:							return L"Alias exists";
		case STATUS_LOGON_NOT_GRANTED:						return L"Logon not granted";
		case STATUS_TOO_MANY_SECRETS:						return L"Too many secrets";
		case STATUS_SECRET_TOO_LONG:						return L"Secret too long";
		case STATUS_INTERNAL_DB_ERROR:						return L"Internal db error";
		case STATUS_FULLSCREEN_MODE:						return L"Fullscreen mode";
		case STATUS_TOO_MANY_CONTEXT_IDS:					return L"Too many context ids";
		case STATUS_LOGON_TYPE_NOT_GRANTED:					return L"Logon type not granted";
		case STATUS_NOT_REGISTRY_FILE:						return L"Not registry file";
		case STATUS_NT_CROSS_ENCRYPTION_REQUIRED:			return L"NT cross encryption required";
		case STATUS_DOMAIN_CTRLR_CONFIG_ERROR:				return L"Domain ctrlr config error";
		case STATUS_FT_MISSING_MEMBER:						return L"FT missing member";
		case STATUS_ILL_FORMED_SERVICE_ENTRY:				return L"Ill formed service entry";
		case STATUS_ILLEGAL_CHARACTER:						return L"Illegal character";
		case STATUS_UNMAPPABLE_CHARACTER:					return L"Unmappable character";
		case STATUS_UNDEFINED_CHARACTER:					return L"Undefined character";
		case STATUS_FLOPPY_VOLUME:							return L"Floppy volume";
		case STATUS_FLOPPY_ID_MARK_NOT_FOUND:				return L"Floppy id mark not found";
		case STATUS_FLOPPY_WRONG_CYLINDER:					return L"Floppy wrong cylinder";
		case STATUS_FLOPPY_UNKNOWN_ERROR:					return L"Floppy unknown error";
		case STATUS_FLOPPY_BAD_REGISTERS:					return L"Floppy bad registers";
		case STATUS_DISK_RECALIBRATE_FAILED:				return L"Disk recalibrate failed";
		case STATUS_DISK_OPERATION_FAILED:					return L"Disk operation failed";
		case STATUS_DISK_RESET_FAILED:						return L"Disk reset failed";
		case STATUS_SHARED_IRQ_BUSY:						return L"Shared irq busy";
		case STATUS_FT_ORPHANING:							return L"FT orphaning";
		case STATUS_PARTITION_FAILURE:						return L"Partition failure";
		case STATUS_INVALID_BLOCK_LENGTH:					return L"Invalid block length";
		case STATUS_DEVICE_NOT_PARTITIONED:					return L"Device not partitioned";
		case STATUS_UNABLE_TO_LOCK_MEDIA:					return L"Unable to lock media";
		case STATUS_UNABLE_TO_UNLOAD_MEDIA:					return L"Unable to unload media";
		case STATUS_EOM_OVERFLOW:							return L"EOM overflow";
		case STATUS_NO_MEDIA:								return L"No media";
		case STATUS_NO_SUCH_MEMBER:							return L"No such member";
		case STATUS_INVALID_MEMBER:							return L"Invalid member";
		case STATUS_KEY_DELETED:							return L"Key deleted";
		case STATUS_NO_LOG_SPACE:							return L"No log space";
		case STATUS_TOO_MANY_SIDS:							return L"Too many sids";
		case STATUS_LM_CROSS_ENCRYPTION_REQUIRED:			return L"Lm cross encryption required";
		case STATUS_KEY_HAS_CHILDREN:						return L"Key has children";
		case STATUS_CHILD_MUST_BE_VOLATILE:					return L"Child must be volatile";
		case STATUS_DEVICE_CONFIGURATION_ERROR:				return L"Device configuration error";
		case STATUS_DRIVER_INTERNAL_ERROR:					return L"Driver internal error";
		case STATUS_INVALID_DEVICE_STATE:					return L"Invalid device state";
		case STATUS_IO_DEVICE_ERROR:						return L"IO device error";
		case STATUS_DEVICE_PROTOCOL_ERROR:					return L"Device protocol error";
		case STATUS_BACKUP_CONTROLLER:						return L"Backup controller";
		case STATUS_LOG_FILE_FULL:							return L"Log file full";
		case STATUS_TOO_LATE:								return L"Too late";
		case STATUS_NO_TRUST_LSA_SECRET:					return L"No trust lsa secret";
		case STATUS_NO_TRUST_SAM_ACCOUNT:					return L"No trust sam account";
		case STATUS_TRUSTED_DOMAIN_FAILURE:					return L"Trusted domain failure";
		case STATUS_TRUSTED_RELATIONSHIP_FAILURE:			return L"Trusted relationship failure";
		case STATUS_EVENTLOG_FILE_CORRUPT:					return L"Eventlog file corrupt";
		case STATUS_EVENTLOG_CANT_START:					return L"Eventlog cant start";
		case STATUS_TRUST_FAILURE:							return L"Trust failure";
		case STATUS_MUTANT_LIMIT_EXCEEDED:					return L"Mutant limit exceeded";
		case STATUS_NETLOGON_NOT_STARTED:					return L"Netlogon not started";
		case STATUS_ACCOUNT_EXPIRED:						return L"Account expired";
		case STATUS_POSSIBLE_DEADLOCK:						return L"Possible deadlock";
		case STATUS_NETWORK_CREDENTIAL_CONFLICT:			return L"Network credential conflict";
		case STATUS_REMOTE_SESSION_LIMIT:					return L"Remote session limit";
		case STATUS_EVENTLOG_FILE_CHANGED:					return L"Eventlog file changed";
		case STATUS_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT:		return L"Nologon interdomain trust account";
		case STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT:		return L"Nologon workstation trust account";
		case STATUS_NOLOGON_SERVER_TRUST_ACCOUNT:			return L"Nologon server trust account";
		case STATUS_DOMAIN_TRUST_INCONSISTENT:				return L"Domain trust inconsistent";
		case STATUS_FS_DRIVER_REQUIRED:						return L"FS driver required";
		case STATUS_NO_USER_SESSION_KEY:					return L"No user session key";
		case STATUS_USER_SESSION_DELETED:					return L"User session deleted";
		case STATUS_RESOURCE_LANG_NOT_FOUND:				return L"Resource lang not found";
		case STATUS_INSUFF_SERVER_RESOURCES:				return L"Insuff server resources";
		case STATUS_INVALID_BUFFER_SIZE:					return L"Invalid buffer size";
		case STATUS_INVALID_ADDRESS_COMPONENT:				return L"Invalid address component";
		case STATUS_INVALID_ADDRESS_WILDCARD:				return L"Invalid address wildcard";
		case STATUS_TOO_MANY_ADDRESSES:						return L"Too many addresses";
		case STATUS_ADDRESS_ALREADY_EXISTS:					return L"Address already exists";
		case STATUS_ADDRESS_CLOSED:							return L"Address closed";
		case STATUS_CONNECTION_DISCONNECTED:				return L"Connection disconnected";
		case STATUS_CONNECTION_RESET:						return L"Connection reset";
		case STATUS_TOO_MANY_NODES:							return L"Too many nodes";
		case STATUS_TRANSACTION_ABORTED:					return L"Transaction aborted";
		case STATUS_TRANSACTION_TIMED_OUT:					return L"Transaction timed out";
		case STATUS_TRANSACTION_NO_RELEASE:					return L"Transaction no release";
		case STATUS_TRANSACTION_NO_MATCH:					return L"Transaction no match";
		case STATUS_TRANSACTION_RESPONDED:					return L"Transaction responded";
		case STATUS_TRANSACTION_INVALID_ID:					return L"Transaction invalid id";
		case STATUS_TRANSACTION_INVALID_TYPE:				return L"Transaction invalid type";
		case STATUS_NOT_SERVER_SESSION:						return L"Not server session";
		case STATUS_NOT_CLIENT_SESSION:						return L"Not client session";
		case STATUS_CANNOT_LOAD_REGISTRY_FILE:				return L"Cannot load registry file";
		case STATUS_DEBUG_ATTACH_FAILED:					return L"Debug attach failed";
		case STATUS_SYSTEM_PROCESS_TERMINATED:				return L"System process terminated";
		case STATUS_DATA_NOT_ACCEPTED:						return L"Data not accepted";
		case STATUS_NO_BROWSER_SERVERS_FOUND:				return L"No browser servers found";
		case STATUS_VDM_HARD_ERROR:							return L"Vdm hard error";
		case STATUS_DRIVER_CANCEL_TIMEOUT:					return L"Driver cancel timeout";
		case STATUS_REPLY_MESSAGE_MISMATCH:					return L"Reply message mismatch";
		case STATUS_MAPPED_ALIGNMENT:						return L"Mapped alignment";
		case STATUS_IMAGE_CHECKSUM_MISMATCH:				return L"Image checksum mismatch";
		case STATUS_LOST_WRITEBEHIND_DATA:					return L"Lost writebehind data";
		case STATUS_CLIENT_SERVER_PARAMETERS_INVALID:		return L"Client server parameters invalid";
		case STATUS_PASSWORD_MUST_CHANGE:					return L"Password must change";
		case STATUS_NOT_FOUND:								return L"Not found";
		case STATUS_NOT_TINY_STREAM:						return L"Not tiny stream";
		case STATUS_RECOVERY_FAILURE:						return L"Recovery failure";
		case STATUS_STACK_OVERFLOW_READ:					return L"Stack overflow read";
		case STATUS_FAIL_CHECK:								return L"Fail check";
		case STATUS_DUPLICATE_OBJECTID:						return L"Duplicate objectid";
		case STATUS_OBJECTID_EXISTS:						return L"Objectid exists";
		case STATUS_CONVERT_TO_LARGE:						return L"Convert to large";
		case STATUS_RETRY:									return L"Retry";
		case STATUS_FOUND_OUT_OF_SCOPE:						return L"Found out of scope";
		case STATUS_ALLOCATE_BUCKET:						return L"Allocate bucket";
		case STATUS_PROPSET_NOT_FOUND:						return L"Propset not found";
		case STATUS_MARSHALL_OVERFLOW:						return L"Marshall overflow";
		case STATUS_INVALID_VARIANT:						return L"Invalid variant";
		case STATUS_DOMAIN_CONTROLLER_NOT_FOUND:			return L"Domain controller not found";
		case STATUS_ACCOUNT_LOCKED_OUT:						return L"Account locked out";
		case STATUS_HANDLE_NOT_CLOSABLE:					return L"Handle not closable";
		case STATUS_CONNECTION_REFUSED:						return L"Connection refused";
		case STATUS_GRACEFUL_DISCONNECT:					return L"Graceful disconnect";
		case STATUS_ADDRESS_ALREADY_ASSOCIATED:				return L"Address already associated";
		case STATUS_ADDRESS_NOT_ASSOCIATED:					return L"Address not associated";
		case STATUS_CONNECTION_INVALID:						return L"Connection invalid";
		case STATUS_CONNECTION_ACTIVE:						return L"Connection active";
		case STATUS_NETWORK_UNREACHABLE:					return L"Network unreachable";
		case STATUS_HOST_UNREACHABLE:						return L"Host unreachable";
		case STATUS_PROTOCOL_UNREACHABLE:					return L"Protocol unreachable";
		case STATUS_PORT_UNREACHABLE:						return L"Port unreachable";
		case STATUS_REQUEST_ABORTED:						return L"Request aborted";
		case STATUS_CONNECTION_ABORTED:						return L"Connection aborted";
		case STATUS_BAD_COMPRESSION_BUFFER:					return L"Bad compression buffer";
		case STATUS_USER_MAPPED_FILE:						return L"User mapped file";
		case STATUS_AUDIT_FAILED:							return L"Audit failed";
		case STATUS_TIMER_RESOLUTION_NOT_SET:				return L"Timer resolution not set";
		case STATUS_CONNECTION_COUNT_LIMIT:					return L"Connection count limit";
		case STATUS_LOGIN_TIME_RESTRICTION:					return L"Login time restriction";
		case STATUS_LOGIN_WKSTA_RESTRICTION:				return L"Login wksta restriction";
		case STATUS_IMAGE_MP_UP_MISMATCH:					return L"Image mp up mismatch";
		case STATUS_INSUFFICIENT_LOGON_INFO:				return L"Insufficient logon info";
		case STATUS_BAD_DLL_ENTRYPOINT:						return L"Bad dll entrypoint";
		case STATUS_BAD_SERVICE_ENTRYPOINT:					return L"Bad service entrypoint";
		case STATUS_LPC_REPLY_LOST:							return L"Lpc reply lost";
		case STATUS_IP_ADDRESS_CONFLICT1:					return L"IP address conflict1";
		case STATUS_IP_ADDRESS_CONFLICT2:					return L"IP address conflict2";
		case STATUS_REGISTRY_QUOTA_LIMIT:					return L"Registry quota limit";
		case STATUS_PATH_NOT_COVERED:						return L"Path not covered";
		case STATUS_NO_CALLBACK_ACTIVE:						return L"No callback active";
		case STATUS_LICENSE_QUOTA_EXCEEDED:					return L"License quota exceeded";
		case STATUS_PWD_TOO_SHORT:							return L"Pwd too short";
		case STATUS_PWD_TOO_RECENT:							return L"Pwd too recent";
		case STATUS_PWD_HISTORY_CONFLICT:					return L"Pwd history conflict";
		case STATUS_PLUGPLAY_NO_DEVICE:						return L"Plugplay no device";
		case STATUS_UNSUPPORTED_COMPRESSION:				return L"Unsupported compression";
		case STATUS_INVALID_HW_PROFILE:						return L"Invalid hw profile";
		case STATUS_INVALID_PLUGPLAY_DEVICE_PATH:			return L"Invalid plugplay device path";
		case STATUS_DRIVER_ORDINAL_NOT_FOUND:				return L"Driver ordinal not found";
		case STATUS_DRIVER_ENTRYPOINT_NOT_FOUND:			return L"Driver entrypoint not found";
		case STATUS_RESOURCE_NOT_OWNED:						return L"Resource not owned";
		case STATUS_TOO_MANY_LINKS:							return L"Too many links";
		case STATUS_QUOTA_LIST_INCONSISTENT:				return L"Quota list inconsistent";
		case STATUS_FILE_IS_OFFLINE:						return L"File is offline";
		case STATUS_DS_NO_MORE_RIDS:						return L"DS no more rids";
		case STATUS_NOT_A_REPARSE_POINT:					return L"Not a reparse point";
		//case STATUS_NO_SUCH_JOB:							return L"No such job";
		//case STATUS_RPC_PROTSEQ_NOT_SUPPORTED:			return L"Rpc protseq not supported";
    }
	return L"Unknown";
}
